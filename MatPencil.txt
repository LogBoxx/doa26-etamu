% Parameters
N = 4;              % Number of antennas
d = 0.5;            % Element spacing (in wavelengths)
theta_true = 30;    % True angle of arrival in degrees
SNR = 20;           % Signal-to-Noise Ratio in dB
L = 2;              % Pencil parameter (usually between N/3 and N/2)
N_iter = 50;        % # of iterations

% Signal Generation
%for i = 1:N_iter
theta_rad = deg2rad(theta_true);
a = exp(-1j * 2 * pi * d * (0:N-1)' * sin(theta_rad)); % Steering vector
s = exp(1j * 2 * pi * randn(1)); % Complex signal
noise = (randn(N,1) + 1j*randn(N,1)) * 10^(-SNR/10) / sqrt(2);
x = a * s + noise; % Received signal vector

% 1. Form the Data Matrices (Shifting Window)
% Y1 is the first N-1 elements, Y2 is the last N-1 elements
Y1 = x(1:N-1);
Y2 = x(2:N);

% 2. Total Least Squares (TLS) Approach
% Construct the matrix [Y1 | Y2] and find its SVD
Z = [Y1, Y2];
[U, S, V] = svd(Z, 0);

% For a single source, we look at the signal subspace
% V = [V11 V12; V21 V22]. The TLS solution is -V12 * inv(V22)
V12 = V(1, 2);
V22 = V(2, 2);
z_tls = -V12 / V22;

% 3. Extract Angle
% The pole z = exp(j * 2 * pi * d * sin(theta))
estimated_theta_rad = abs(asin(angle(z_tls) / (2 * pi * d)));
estimated_theta_deg = real(rad2deg(estimated_theta_rad));

% Results
%fprintf('True Angle: %.2f°\n', theta_true);
%fprintf('Estimated Angle (TLS-MP): %.2f°\n', estimated_theta_deg);

h = compass(exp(1j*estimated_theta_rad));
ax = ancestor(h(1), 'polaraxes');
ax.RTick = [];
ax.RGrid = 'off';
ax.ThetaTick = [];
ax.ThetaGrid = 'off';

theta_true = theta_true + 1;
pause(0.2)
%end